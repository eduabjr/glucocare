{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { getDB, initDB } from \"./dbService\";\nvar DRIVE_UPLOAD_URL = 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart';\nvar DRIVE_FILES_URL = 'https://www.googleapis.com/drive/v3/files';\nvar DRIVE_FILE_NAME = 'glucocare_readings.json';\nfunction uploadReadingsToDrive(_x) {\n  return _uploadReadingsToDrive.apply(this, arguments);\n}\nfunction _uploadReadingsToDrive() {\n  _uploadReadingsToDrive = _asyncToGenerator(function* (accessToken) {\n    try {\n      if (!accessToken) throw new Error(\"Token de acesso invÃ¡lido\");\n      yield initDB();\n      var db = getDB();\n      var readings = yield new Promise(function (resolve, reject) {\n        db.transaction(function (tx) {\n          tx.executeSql('SELECT * FROM readings ORDER BY measurement_time DESC;', [], function (_, _ref) {\n            var rows = _ref.rows;\n            return resolve(rows._array);\n          }, function (_, err) {\n            console.error(\"Erro ao executar SQL:\", err);\n            reject(err);\n            return true;\n          });\n        });\n      });\n      var fileContent = JSON.stringify(readings, null, 2);\n      var boundary = 'glucocare_boundary';\n      var metadata = {\n        name: DRIVE_FILE_NAME,\n        mimeType: 'application/json'\n      };\n      var body = \"--\" + boundary + \"\\r\\n\" + 'Content-Type: application/json; charset=UTF-8\\r\\n\\r\\n' + JSON.stringify(metadata) + (\"\\r\\n--\" + boundary + \"\\r\\n\") + 'Content-Type: application/json\\r\\n\\r\\n' + fileContent + (\"\\r\\n--\" + boundary + \"--\");\n      var q = encodeURIComponent(\"name='\" + DRIVE_FILE_NAME + \"' and trashed=false\");\n      var searchResp = yield fetch(DRIVE_FILES_URL + \"?q=\" + q + \"&spaces=drive\", {\n        headers: {\n          Authorization: \"Bearer \" + accessToken\n        }\n      });\n      var fileId = null;\n      if (searchResp.ok) {\n        var searchData = yield searchResp.json();\n        if (searchData.files && searchData.files.length > 0) {\n          fileId = searchData.files[0].id;\n        }\n      } else {\n        throw new Error(\"Falha ao buscar arquivos no Drive. Status: \" + searchResp.status);\n      }\n      var url = fileId ? \"https://www.googleapis.com/upload/drive/v3/files/\" + fileId + \"?uploadType=multipart\" : DRIVE_UPLOAD_URL;\n      var res = yield fetch(url, {\n        method: fileId ? 'PATCH' : 'POST',\n        headers: {\n          Authorization: \"Bearer \" + accessToken,\n          'Content-Type': \"multipart/related; boundary=\" + boundary\n        },\n        body: body\n      });\n      if (!res.ok) {\n        var text = yield res.text();\n        throw new Error(\"Drive upload falhou (status \" + res.status + \"): \" + text);\n      }\n      yield saveSyncTimestamp(db, new Date().toISOString());\n      return true;\n    } catch (err) {\n      console.error('uploadReadingsToDrive - erro:', err);\n      throw err;\n    }\n  });\n  return _uploadReadingsToDrive.apply(this, arguments);\n}\nfunction saveSyncTimestamp(_x2, _x3) {\n  return _saveSyncTimestamp.apply(this, arguments);\n}\nfunction _saveSyncTimestamp() {\n  _saveSyncTimestamp = _asyncToGenerator(function* (db, isoString) {\n    return new Promise(function (resolve, reject) {\n      db.transaction(function (tx) {\n        tx.executeSql(\"INSERT OR REPLACE INTO sync_meta (key, value) VALUES (?, ?);\", ['last_sync', isoString]);\n      }, function (err) {\n        console.warn(\"saveSyncTimestamp falhou:\", err);\n        reject(err);\n        return true;\n      }, function () {\n        return resolve(true);\n      });\n    });\n  });\n  return _saveSyncTimestamp.apply(this, arguments);\n}\nexport default {\n  uploadReadingsToDrive: uploadReadingsToDrive,\n  saveSyncTimestamp: saveSyncTimestamp\n};","map":{"version":3,"names":["getDB","initDB","DRIVE_UPLOAD_URL","DRIVE_FILES_URL","DRIVE_FILE_NAME","uploadReadingsToDrive","_x","_uploadReadingsToDrive","apply","arguments","_asyncToGenerator","accessToken","Error","db","readings","Promise","resolve","reject","transaction","tx","executeSql","_","_ref","rows","_array","err","console","error","fileContent","JSON","stringify","boundary","metadata","name","mimeType","body","q","encodeURIComponent","searchResp","fetch","headers","Authorization","fileId","ok","searchData","json","files","length","id","status","url","res","method","text","saveSyncTimestamp","Date","toISOString","_x2","_x3","_saveSyncTimestamp","isoString","warn"],"sources":["C:/Users/UsuÃ¡rio/Desktop/glucocare/src/services/googleSync.ts"],"sourcesContent":["import { getDB, initDB } from './dbService';\nimport * as SQLite from 'expo-sqlite';  // Corrigido para usar expo-sqlite corretamente\n\nconst DRIVE_UPLOAD_URL = 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart';\nconst DRIVE_FILES_URL = 'https://www.googleapis.com/drive/v3/files';\nconst DRIVE_FILE_NAME = 'glucocare_readings.json';\n\n// Tipos para os dados de leitura\ninterface Reading {\n  id: string;\n  measurement_time: string;\n  glucose_level: number;\n  meal_context: string | null;\n  time_since_meal: string | null;\n  notes: string | null;\n}\n\n/**\n * ðŸ”¹ Upload leituras para o Google Drive\n */\nasync function uploadReadingsToDrive(accessToken: string): Promise<boolean> {\n  try {\n    if (!accessToken) throw new Error(\"Token de acesso invÃ¡lido\");\n\n    await initDB();\n    const db = getDB();\n\n    // Buscar leituras do banco de dados\n    const readings: Reading[] = await new Promise((resolve, reject) => {\n      db.transaction((tx: SQLite.SQLTransaction) => {  // Usando o tipo correto SQLTransaction\n        tx.executeSql(\n          'SELECT * FROM readings ORDER BY measurement_time DESC;',\n          [],\n          (_, { rows }: { rows: SQLite.SQLResultSetRowList }) => resolve(rows._array),  // Tipagem de rows\n          (_, err: SQLite.SQLError) => {\n            console.error(\"Erro ao executar SQL:\", err);\n            reject(err);  // Agora o erro Ã© tratado corretamente\n            return true;  // Retorna true para indicar que o erro foi tratado\n          }\n        );\n      });\n    });\n\n    const fileContent = JSON.stringify(readings, null, 2);\n    const boundary = 'glucocare_boundary';\n    const metadata = {\n      name: DRIVE_FILE_NAME,\n      mimeType: 'application/json',\n    };\n\n    const body =\n      `--${boundary}\\r\\n` +\n      'Content-Type: application/json; charset=UTF-8\\r\\n\\r\\n' +\n      JSON.stringify(metadata) +\n      `\\r\\n--${boundary}\\r\\n` +\n      'Content-Type: application/json\\r\\n\\r\\n' +\n      fileContent +\n      `\\r\\n--${boundary}--`;\n\n    // Verifica se o arquivo jÃ¡ existe no Google Drive\n    const q = encodeURIComponent(`name='${DRIVE_FILE_NAME}' and trashed=false`);\n    const searchResp = await fetch(`${DRIVE_FILES_URL}?q=${q}&spaces=drive`, {\n      headers: { Authorization: `Bearer ${accessToken}` },\n    });\n\n    let fileId: string | null = null;\n    if (searchResp.ok) {\n      const searchData = await searchResp.json();\n      if (searchData.files && searchData.files.length > 0) {\n        fileId = searchData.files[0].id;\n      }\n    } else {\n      // Aqui vocÃª pode tratar se a busca falhar, como uma falha na API\n      throw new Error(`Falha ao buscar arquivos no Drive. Status: ${searchResp.status}`);\n    }\n\n    // Decide se cria ou atualiza o arquivo\n    const url = fileId\n      ? `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`\n      : DRIVE_UPLOAD_URL;\n\n    const res = await fetch(url, {\n      method: fileId ? 'PATCH' : 'POST',\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'Content-Type': `multipart/related; boundary=${boundary}`,\n      },\n      body,\n    });\n\n    if (!res.ok) {\n      const text = await res.text();\n      throw new Error(`Drive upload falhou (status ${res.status}): ${text}`);\n    }\n\n    // ApÃ³s o upload, salva o timestamp da sincronizaÃ§Ã£o\n    await saveSyncTimestamp(db, new Date().toISOString());\n    return true;\n  } catch (err) {\n    console.error('uploadReadingsToDrive - erro:', err);\n    throw err;\n  }\n}\n\n/**\n * ðŸ”¹ Salva timestamp de sincronizaÃ§Ã£o no SQLite\n */\nasync function saveSyncTimestamp(db: SQLite.Database, isoString: string): Promise<boolean> {\n  return new Promise((resolve, reject) => {\n    db.transaction(\n      (tx: SQLite.SQLTransaction) => {  // Usando o tipo correto SQLTransaction\n        tx.executeSql(\n          `INSERT OR REPLACE INTO sync_meta (key, value) VALUES (?, ?);`,\n          ['last_sync', isoString]\n        );\n      },\n      (err: SQLite.SQLError) => {  // Tipagem explÃ­cita de err\n        console.warn(\"saveSyncTimestamp falhou:\", err);\n        reject(err);\n        return true;  // Retorna true para indicar que o erro foi tratado\n      },\n      () => resolve(true)\n    );\n  });\n}\n\nexport default {\n  uploadReadingsToDrive,\n  saveSyncTimestamp,\n};\n"],"mappings":";AAAA,SAASA,KAAK,EAAEC,MAAM;AAGtB,IAAMC,gBAAgB,GAAG,uEAAuE;AAChG,IAAMC,eAAe,GAAG,2CAA2C;AACnE,IAAMC,eAAe,GAAG,yBAAyB;AAAC,SAenCC,qBAAqBA,CAAAC,EAAA;EAAA,OAAAC,sBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,uBAAA;EAAAA,sBAAA,GAAAG,iBAAA,CAApC,WAAqCC,WAAmB,EAAoB;IAC1E,IAAI;MACF,IAAI,CAACA,WAAW,EAAE,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;MAE7D,MAAMX,MAAM,CAAC,CAAC;MACd,IAAMY,EAAE,GAAGb,KAAK,CAAC,CAAC;MAGlB,IAAMc,QAAmB,SAAS,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;QACjEJ,EAAE,CAACK,WAAW,CAAC,UAACC,EAAyB,EAAK;UAC5CA,EAAE,CAACC,UAAU,CACX,wDAAwD,EACxD,EAAE,EACF,UAACC,CAAC,EAAAC,IAAA;YAAA,IAAIC,IAAI,GAAAD,IAAA,CAAJC,IAAI;YAAA,OAA6CP,OAAO,CAACO,IAAI,CAACC,MAAM,CAAC;UAAA,GAC3E,UAACH,CAAC,EAAEI,GAAoB,EAAK;YAC3BC,OAAO,CAACC,KAAK,CAAC,uBAAuB,EAAEF,GAAG,CAAC;YAC3CR,MAAM,CAACQ,GAAG,CAAC;YACX,OAAO,IAAI;UACb,CACF,CAAC;QACH,CAAC,CAAC;MACJ,CAAC,CAAC;MAEF,IAAMG,WAAW,GAAGC,IAAI,CAACC,SAAS,CAAChB,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;MACrD,IAAMiB,QAAQ,GAAG,oBAAoB;MACrC,IAAMC,QAAQ,GAAG;QACfC,IAAI,EAAE7B,eAAe;QACrB8B,QAAQ,EAAE;MACZ,CAAC;MAED,IAAMC,IAAI,GACR,OAAKJ,QAAQ,YACb,uDAAuD,GACvDF,IAAI,CAACC,SAAS,CAACE,QAAQ,CAAC,eACfD,QAAQ,UAAM,GACvB,wCAAwC,GACxCH,WAAW,eACFG,QAAQ,QAAI;MAGvB,IAAMK,CAAC,GAAGC,kBAAkB,YAAUjC,eAAe,wBAAqB,CAAC;MAC3E,IAAMkC,UAAU,SAASC,KAAK,CAAIpC,eAAe,WAAMiC,CAAC,oBAAiB;QACvEI,OAAO,EAAE;UAAEC,aAAa,cAAY9B;QAAc;MACpD,CAAC,CAAC;MAEF,IAAI+B,MAAqB,GAAG,IAAI;MAChC,IAAIJ,UAAU,CAACK,EAAE,EAAE;QACjB,IAAMC,UAAU,SAASN,UAAU,CAACO,IAAI,CAAC,CAAC;QAC1C,IAAID,UAAU,CAACE,KAAK,IAAIF,UAAU,CAACE,KAAK,CAACC,MAAM,GAAG,CAAC,EAAE;UACnDL,MAAM,GAAGE,UAAU,CAACE,KAAK,CAAC,CAAC,CAAC,CAACE,EAAE;QACjC;MACF,CAAC,MAAM;QAEL,MAAM,IAAIpC,KAAK,iDAA+C0B,UAAU,CAACW,MAAQ,CAAC;MACpF;MAGA,IAAMC,GAAG,GAAGR,MAAM,yDACsCA,MAAM,6BAC1DxC,gBAAgB;MAEpB,IAAMiD,GAAG,SAASZ,KAAK,CAACW,GAAG,EAAE;QAC3BE,MAAM,EAAEV,MAAM,GAAG,OAAO,GAAG,MAAM;QACjCF,OAAO,EAAE;UACPC,aAAa,cAAY9B,WAAa;UACtC,cAAc,mCAAiCoB;QACjD,CAAC;QACDI,IAAI,EAAJA;MACF,CAAC,CAAC;MAEF,IAAI,CAACgB,GAAG,CAACR,EAAE,EAAE;QACX,IAAMU,IAAI,SAASF,GAAG,CAACE,IAAI,CAAC,CAAC;QAC7B,MAAM,IAAIzC,KAAK,kCAAgCuC,GAAG,CAACF,MAAM,WAAMI,IAAM,CAAC;MACxE;MAGA,MAAMC,iBAAiB,CAACzC,EAAE,EAAE,IAAI0C,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC;MACrD,OAAO,IAAI;IACb,CAAC,CAAC,OAAO/B,GAAG,EAAE;MACZC,OAAO,CAACC,KAAK,CAAC,+BAA+B,EAAEF,GAAG,CAAC;MACnD,MAAMA,GAAG;IACX;EACF,CAAC;EAAA,OAAAlB,sBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAKc6C,iBAAiBA,CAAAG,GAAA,EAAAC,GAAA;EAAA,OAAAC,kBAAA,CAAAnD,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAkD,mBAAA;EAAAA,kBAAA,GAAAjD,iBAAA,CAAhC,WAAiCG,EAAmB,EAAE+C,SAAiB,EAAoB;IACzF,OAAO,IAAI7C,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;MACtCJ,EAAE,CAACK,WAAW,CACZ,UAACC,EAAyB,EAAK;QAC7BA,EAAE,CAACC,UAAU,iEAEX,CAAC,WAAW,EAAEwC,SAAS,CACzB,CAAC;MACH,CAAC,EACD,UAACnC,GAAoB,EAAK;QACxBC,OAAO,CAACmC,IAAI,CAAC,2BAA2B,EAAEpC,GAAG,CAAC;QAC9CR,MAAM,CAACQ,GAAG,CAAC;QACX,OAAO,IAAI;MACb,CAAC,EACD;QAAA,OAAMT,OAAO,CAAC,IAAI,CAAC;MAAA,CACrB,CAAC;IACH,CAAC,CAAC;EACJ,CAAC;EAAA,OAAA2C,kBAAA,CAAAnD,KAAA,OAAAC,SAAA;AAAA;AAED,eAAe;EACbJ,qBAAqB,EAArBA,qBAAqB;EACrBiD,iBAAiB,EAAjBA;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}