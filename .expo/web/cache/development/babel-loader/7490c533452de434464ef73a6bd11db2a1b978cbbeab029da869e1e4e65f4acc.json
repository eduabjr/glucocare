{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport * as SQLite from 'expo-sqlite';\nimport { db, auth } from \"../config/firebase\";\nimport { doc, setDoc, serverTimestamp } from 'firebase/firestore';\nvar DB_NAME = 'glucocare.db';\nvar dbInstance = null;\nexport function getDB() {\n  if (!dbInstance) {\n    dbInstance = SQLite.openDatabase(DB_NAME);\n  }\n  return dbInstance;\n}\nexport function initDB() {\n  return _initDB.apply(this, arguments);\n}\nfunction _initDB() {\n  _initDB = _asyncToGenerator(function* () {\n    return new Promise(function (resolve, reject) {\n      var database = getDB();\n      database.transaction(function (tx) {\n        tx.executeSql(\"CREATE TABLE IF NOT EXISTS users (\\n                        id TEXT PRIMARY KEY NOT NULL,\\n                        full_name TEXT,\\n                        email TEXT,\\n                        google_id TEXT,\\n                        onboarding_completed INTEGER DEFAULT 0,\\n                        biometric_enabled INTEGER DEFAULT 0,\\n                        weight REAL,\\n                        height REAL,\\n                        birth_date TEXT,\\n                        diabetes_condition TEXT,\\n                        restriction TEXT,\\n                        synced_at TEXT DEFAULT NULL \\n                    );\");\n        tx.executeSql(\"CREATE TABLE IF NOT EXISTS readings (\\n                        id TEXT PRIMARY KEY NOT NULL,\\n                        measurement_time TEXT,\\n                        glucose_level REAL,\\n                        meal_context TEXT,\\n                        time_since_meal TEXT,\\n                        notes TEXT,\\n                        synced_at TEXT DEFAULT NULL \\n                    );\");\n        tx.executeSql(\"CREATE TABLE IF NOT EXISTS sync_meta (\\n                        key TEXT PRIMARY KEY NOT NULL,\\n                        value TEXT\\n                    );\");\n      }, function (err) {\n        console.error('initDB - erro transaction:', err);\n        reject(err);\n      }, function () {\n        console.log('Banco inicializado com sucesso ✅');\n        resolve(true);\n      });\n    });\n  });\n  return _initDB.apply(this, arguments);\n}\nfunction normalizeUserRow(row) {\n  var _row$full_name, _row$email, _row$weight, _row$height, _row$birth_date, _row$diabetes_conditi, _row$restriction, _row$synced_at;\n  return {\n    id: row.id,\n    name: String((_row$full_name = row.full_name) != null ? _row$full_name : ''),\n    email: String((_row$email = row.email) != null ? _row$email : ''),\n    googleId: row.google_id || null,\n    onboardingCompleted: !!row.onboarding_completed,\n    biometricEnabled: !!row.biometric_enabled,\n    weight: (_row$weight = row.weight) != null ? _row$weight : null,\n    height: (_row$height = row.height) != null ? _row$height : null,\n    birthDate: String((_row$birth_date = row.birth_date) != null ? _row$birth_date : ''),\n    condition: String((_row$diabetes_conditi = row.diabetes_condition) != null ? _row$diabetes_conditi : ''),\n    restriction: String((_row$restriction = row.restriction) != null ? _row$restriction : ''),\n    syncedAt: (_row$synced_at = row.synced_at) != null ? _row$synced_at : null\n  };\n}\nfunction normalizeReadingRow(row) {\n  var _row$meal_context, _row$time_since_meal, _row$notes, _row$synced_at2;\n  var timestamp = row.measurement_time ? new Date(row.measurement_time).getTime() : Date.now();\n  return {\n    id: row.id,\n    measurement_time: String(row.measurement_time),\n    timestamp: timestamp,\n    glucose_level: row.glucose_level,\n    meal_context: (_row$meal_context = row.meal_context) != null ? _row$meal_context : null,\n    time_since_meal: (_row$time_since_meal = row.time_since_meal) != null ? _row$time_since_meal : null,\n    notes: (_row$notes = row.notes) != null ? _row$notes : null,\n    syncedAt: (_row$synced_at2 = row.synced_at) != null ? _row$synced_at2 : null\n  };\n}\nfunction getFirebaseUID() {\n  var _auth$currentUser;\n  return ((_auth$currentUser = auth.currentUser) == null ? void 0 : _auth$currentUser.uid) || null;\n}\nexport function syncUserProfileToFirestore(_x) {\n  return _syncUserProfileToFirestore.apply(this, arguments);\n}\nfunction _syncUserProfileToFirestore() {\n  _syncUserProfileToFirestore = _asyncToGenerator(function* (profile) {\n    var uid = getFirebaseUID();\n    if (!uid) {\n      console.warn(\"Usuário não autenticado no Firebase. Sincronização de perfil ignorada.\");\n      return;\n    }\n    try {\n      var userRef = doc(db, 'users', uid);\n      var profileData = {\n        full_name: profile.name,\n        email: profile.email,\n        google_id: profile.googleId || null,\n        onboarding_completed: profile.onboardingCompleted,\n        biometric_enabled: profile.biometricEnabled,\n        weight: profile.weight,\n        height: profile.height,\n        birth_date: profile.birthDate,\n        diabetes_condition: profile.condition,\n        restriction: profile.restriction,\n        syncedAt: serverTimestamp()\n      };\n      yield setDoc(userRef, profileData, {\n        merge: true\n      });\n      yield new Promise(function (resolve, reject) {\n        getDB().transaction(function (tx) {\n          tx.executeSql(\"UPDATE users SET synced_at = ? WHERE id = ?;\", [new Date().toISOString(), profile.id], function () {\n            return resolve();\n          }, function (_, err) {\n            reject(err);\n            return false;\n          });\n        }, function (err) {\n          return reject(err);\n        }, function () {\n          return resolve();\n        });\n      });\n      console.log(\"Perfil do usu\\xE1rio \" + uid + \" sincronizado no Firestore.\");\n    } catch (error) {\n      console.error(\"Erro ao sincronizar perfil do usuário com Firestore:\", error);\n      throw error;\n    }\n  });\n  return _syncUserProfileToFirestore.apply(this, arguments);\n}\nexport function syncReadingToFirestore(_x2) {\n  return _syncReadingToFirestore.apply(this, arguments);\n}\nfunction _syncReadingToFirestore() {\n  _syncReadingToFirestore = _asyncToGenerator(function* (reading) {\n    var uid = getFirebaseUID();\n    if (!uid) {\n      console.warn(\"Usuário não autenticado no Firebase. Sincronização de leitura ignorada.\");\n      return;\n    }\n    try {\n      var readingRef = doc(db, 'users', uid, 'readings', reading.id);\n      var readingData = {\n        id: reading.id,\n        glucose_level: reading.glucose_level,\n        meal_context: reading.meal_context,\n        time_since_meal: reading.time_since_meal,\n        notes: reading.notes,\n        timestamp: reading.timestamp,\n        measurement_time_iso: reading.measurement_time,\n        syncedAt: serverTimestamp(),\n        userId: uid\n      };\n      yield setDoc(readingRef, readingData);\n      yield new Promise(function (resolve, reject) {\n        getDB().transaction(function (tx) {\n          tx.executeSql(\"UPDATE readings SET synced_at = ? WHERE id = ?;\", [new Date().toISOString(), reading.id], function () {\n            return resolve();\n          }, function (_, err) {\n            reject(err);\n            return false;\n          });\n        }, function (err) {\n          return reject(err);\n        }, function () {\n          return resolve();\n        });\n      });\n      console.log(\"Leitura \" + reading.id + \" sincronizada no Firestore.\");\n    } catch (error) {\n      console.error(\"Erro ao sincronizar leitura com Firestore:\", error);\n      throw error;\n    }\n  });\n  return _syncReadingToFirestore.apply(this, arguments);\n}\nexport function saveOrUpdateUser(_x3) {\n  return _saveOrUpdateUser.apply(this, arguments);\n}\nfunction _saveOrUpdateUser() {\n  _saveOrUpdateUser = _asyncToGenerator(function* (profile) {\n    var database = getDB();\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql(\"INSERT OR REPLACE INTO users \\n                     (id, full_name, email, google_id, onboarding_completed, biometric_enabled,\\n                     weight, height, birth_date, diabetes_condition, restriction, synced_at)\\n                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\", [profile.id, profile.name || null, profile.email || null, profile.googleId || null, profile.onboardingCompleted ? 1 : 0, profile.biometricEnabled ? 1 : 0, profile.weight || null, profile.height || null, profile.birthDate || null, profile.condition || null, profile.restriction || null, profile.syncedAt || null]);\n      }, function (err) {\n        console.error('saveOrUpdateUser - erro transaction:', err);\n        reject(err);\n      }, _asyncToGenerator(function* () {\n        try {\n          var user = yield getUser();\n          if (user) {\n            yield syncUserProfileToFirestore(user);\n            resolve(user);\n          } else {\n            resolve(false);\n          }\n        } catch (err) {\n          console.error('saveOrUpdateUser - erro ao buscar ou sincronizar:', err);\n          var _user = yield getUser();\n          resolve(_user || false);\n        }\n      }));\n    });\n  });\n  return _saveOrUpdateUser.apply(this, arguments);\n}\nexport function addReading(_x4) {\n  return _addReading.apply(this, arguments);\n}\nfunction _addReading() {\n  _addReading = _asyncToGenerator(function* (reading) {\n    var database = getDB();\n    var isoTime = new Date(reading.timestamp).toISOString();\n    var readingToSave = _objectSpread(_objectSpread({}, reading), {}, {\n      measurement_time: isoTime\n    });\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql(\"INSERT INTO readings \\n                          (id, measurement_time, glucose_level, meal_context, time_since_meal, notes)\\n                          VALUES (?, ?, ?, ?, ?, ?)\", [readingToSave.id, readingToSave.measurement_time, readingToSave.glucose_level, readingToSave.meal_context || null, readingToSave.time_since_meal || null, readingToSave.notes || null]);\n      }, function (err) {\n        console.error('addReading - erro transaction:', err);\n        reject(err);\n      }, _asyncToGenerator(function* () {\n        try {\n          yield syncReadingToFirestore(readingToSave);\n          resolve(true);\n        } catch (error) {\n          console.warn('Atenção: Falha na sincronização da leitura. Salvo apenas localmente.');\n          resolve(true);\n        }\n      }));\n    });\n  });\n  return _addReading.apply(this, arguments);\n}\nexport function getUser() {\n  return _getUser.apply(this, arguments);\n}\nfunction _getUser() {\n  _getUser = _asyncToGenerator(function* () {\n    var database = getDB();\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql(\"SELECT * FROM users LIMIT 1;\", [], function (_, _ref3) {\n          var rows = _ref3.rows;\n          if (rows.length > 0) {\n            resolve(normalizeUserRow(rows._array[0]));\n          } else {\n            resolve(null);\n          }\n        }, function (_, err) {\n          console.error('getUser - erro:', err);\n          reject(err);\n          return false;\n        });\n      });\n    });\n  });\n  return _getUser.apply(this, arguments);\n}\nexport function listReadings() {\n  return _listReadings.apply(this, arguments);\n}\nfunction _listReadings() {\n  _listReadings = _asyncToGenerator(function* () {\n    var database = getDB();\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql(\"SELECT * FROM readings ORDER BY datetime(measurement_time) DESC;\", [], function (_, result) {\n          var readings = (result.rows._array || []).map(normalizeReadingRow);\n          resolve(readings);\n        });\n      }, function (err) {\n        console.error('listReadings - erro transaction:', err);\n        reject(err);\n      });\n    });\n  });\n  return _listReadings.apply(this, arguments);\n}\nexport function deleteReading(_x5) {\n  return _deleteReading.apply(this, arguments);\n}\nfunction _deleteReading() {\n  _deleteReading = _asyncToGenerator(function* (id) {\n    var database = getDB();\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql('DELETE FROM readings WHERE id = ?;', [id], function (_, result) {\n          resolve(result.rowsAffected > 0);\n        }, function (_, error) {\n          console.error(\"deleteReading - erro SQL:\", error);\n          reject(error);\n          return false;\n        });\n      }, function (error) {\n        console.error(\"deleteReading - erro transaction:\", error);\n        reject(error);\n      }, function () {\n        resolve(true);\n      });\n    });\n  });\n  return _deleteReading.apply(this, arguments);\n}\nexport function clearUser() {\n  return _clearUser.apply(this, arguments);\n}\nfunction _clearUser() {\n  _clearUser = _asyncToGenerator(function* () {\n    var database = getDB();\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql(\"DELETE FROM users;\", [], function () {\n          resolve(true);\n        }, function (_, error) {\n          console.error(\"clearUser - erro SQL:\", error);\n          reject(error);\n          return false;\n        });\n      }, function (error) {\n        console.error(\"clearUser - erro transaction:\", error);\n        reject(error);\n      }, function () {\n        resolve(true);\n      });\n    });\n  });\n  return _clearUser.apply(this, arguments);\n}","map":{"version":3,"names":["SQLite","db","auth","doc","setDoc","serverTimestamp","DB_NAME","dbInstance","getDB","openDatabase","initDB","_initDB","apply","arguments","_asyncToGenerator","Promise","resolve","reject","database","transaction","tx","executeSql","err","console","error","log","normalizeUserRow","row","_row$full_name","_row$email","_row$weight","_row$height","_row$birth_date","_row$diabetes_conditi","_row$restriction","_row$synced_at","id","name","String","full_name","email","googleId","google_id","onboardingCompleted","onboarding_completed","biometricEnabled","biometric_enabled","weight","height","birthDate","birth_date","condition","diabetes_condition","restriction","syncedAt","synced_at","normalizeReadingRow","_row$meal_context","_row$time_since_meal","_row$notes","_row$synced_at2","timestamp","measurement_time","Date","getTime","now","glucose_level","meal_context","time_since_meal","notes","getFirebaseUID","_auth$currentUser","currentUser","uid","syncUserProfileToFirestore","_x","_syncUserProfileToFirestore","profile","warn","userRef","profileData","merge","toISOString","_","syncReadingToFirestore","_x2","_syncReadingToFirestore","reading","readingRef","readingData","measurement_time_iso","userId","saveOrUpdateUser","_x3","_saveOrUpdateUser","user","getUser","addReading","_x4","_addReading","isoTime","readingToSave","_objectSpread","_getUser","_ref3","rows","length","_array","listReadings","_listReadings","result","readings","map","deleteReading","_x5","_deleteReading","rowsAffected","clearUser","_clearUser"],"sources":["C:/Users/Usuário/Desktop/glucocare/src/services/dbService.ts"],"sourcesContent":["import * as SQLite from 'expo-sqlite';\nimport { db, auth } from '../config/firebase'; // ✅ Ajuste: Importação corrigida para caminho comum\nimport { doc, setDoc, serverTimestamp, getDoc } from 'firebase/firestore'; \nimport { User as FirebaseAuthUser } from 'firebase/auth'; \n\n// Definindo o nome do banco\nconst DB_NAME = 'glucocare.db';\nlet dbInstance: SQLite.Database | null = null; \n\n// ----------------------\n// TIPAGEM\n// ----------------------\n\nexport interface UserProfile {\n    id: string; // ID do usuário no SQLite (deve ser o mesmo que o UID do Firebase)\n    name: string;\n    email: string;\n    googleId: string | null; // Tipagem ajustada para aceitar null\n    onboardingCompleted: boolean;\n    biometricEnabled: boolean;\n    weight: number | null;\n    height: number | null;\n    birthDate: string;\n    condition: string;\n    restriction: string;\n    syncedAt: string | null;\n}\n\n/**\n * Interface de Leitura adaptada para o uso da propriedade 'timestamp'\n * para importação de arquivos (usada no fileParsingService).\n */\nexport interface Reading {\n    id: string;\n    // Campo usado para salvar no SQLite (ISO string)\n    measurement_time: string; \n    // Novo campo: Usado pelo parser de arquivos (milissegundos UNIX)\n    timestamp: number; \n    glucose_level: number;\n    meal_context: string | null;\n    time_since_meal: string | null;\n    notes: string | null;\n    syncedAt: string | null; \n}\n\n// ----------------------\n// FUNÇÕES DE SERVIÇO BÁSICAS\n// ----------------------\n\n/**\n * Retorna instância única do DB\n */\nexport function getDB(): SQLite.Database {\n    if (!dbInstance) {\n        // Usando openDatabaseSync (se disponível) ou openDatabase (o padrão)\n        // No Expo, o openDatabase é preferível para compatibilidade.\n        dbInstance = SQLite.openDatabase(DB_NAME);\n    }\n    return dbInstance;\n}\n\n/**\n * Inicializa tabelas do banco\n */\nexport async function initDB(): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n        const database = getDB();\n\n        database.transaction(\n            (tx: SQLite.SQLTransaction) => { \n                // Usuários\n                tx.executeSql(\n                    `CREATE TABLE IF NOT EXISTS users (\n                        id TEXT PRIMARY KEY NOT NULL,\n                        full_name TEXT,\n                        email TEXT,\n                        google_id TEXT,\n                        onboarding_completed INTEGER DEFAULT 0,\n                        biometric_enabled INTEGER DEFAULT 0,\n                        weight REAL,\n                        height REAL,\n                        birth_date TEXT,\n                        diabetes_condition TEXT,\n                        restriction TEXT,\n                        synced_at TEXT DEFAULT NULL \n                    );`\n                );\n\n                // Leituras\n                tx.executeSql(\n                    `CREATE TABLE IF NOT EXISTS readings (\n                        id TEXT PRIMARY KEY NOT NULL,\n                        measurement_time TEXT,\n                        glucose_level REAL,\n                        meal_context TEXT,\n                        time_since_meal TEXT,\n                        notes TEXT,\n                        synced_at TEXT DEFAULT NULL \n                    );`\n                );\n\n                // Metadados de sincronização\n                tx.executeSql(\n                    `CREATE TABLE IF NOT EXISTS sync_meta (\n                        key TEXT PRIMARY KEY NOT NULL,\n                        value TEXT\n                    );`\n                );\n            },\n            (err) => {\n                console.error('initDB - erro transaction:', err);\n                reject(err);\n            },\n            () => {\n                console.log('Banco inicializado com sucesso ✅');\n                resolve(true);\n            }\n        );\n    });\n}\n\n// ----------------------\n// FUNÇÕES DE NORMALIZAÇÃO\n// ----------------------\n\nfunction normalizeUserRow(row: any): UserProfile {\n    return {\n        id: row.id,\n        name: String(row.full_name ?? ''), \n        email: String(row.email ?? ''), \n        googleId: row.google_id || null, // Garante null se for vazio\n        onboardingCompleted: !!row.onboarding_completed,\n        biometricEnabled: !!row.biometric_enabled,\n        weight: row.weight ?? null, \n        height: row.height ?? null, \n        birthDate: String(row.birth_date ?? ''), \n        condition: String(row.diabetes_condition ?? ''), \n        restriction: String(row.restriction ?? ''),\n        syncedAt: row.synced_at ?? null, \n    };\n}\n\nfunction normalizeReadingRow(row: any): Reading {\n    const timestamp = row.measurement_time ? new Date(row.measurement_time).getTime() : Date.now();\n    \n    return {\n        id: row.id,\n        measurement_time: String(row.measurement_time),\n        timestamp: timestamp, \n        glucose_level: row.glucose_level,\n        meal_context: row.meal_context ?? null,\n        time_since_meal: row.time_since_meal ?? null,\n        notes: row.notes ?? null,\n        syncedAt: row.synced_at ?? null, \n    };\n}\n\n// ----------------------\n// FUNÇÕES DE SINCRONIZAÇÃO (FIREBASE)\n// ----------------------\n\n/**\n * Retorna o UID do usuário logado no Firebase Auth.\n */\nfunction getFirebaseUID(): string | null {\n    return auth.currentUser?.uid || null;\n}\n\n/**\n * Sincroniza o objeto UserProfile com o Cloud Firestore.\n */\nexport async function syncUserProfileToFirestore(profile: UserProfile): Promise<void> {\n    const uid = getFirebaseUID();\n\n    if (!uid) {\n        console.warn(\"Usuário não autenticado no Firebase. Sincronização de perfil ignorada.\");\n        return;\n    }\n\n    try {\n        const userRef = doc(db, 'users', uid);\n\n        const profileData = {\n            full_name: profile.name,\n            email: profile.email,\n            google_id: profile.googleId || null,\n            onboarding_completed: profile.onboardingCompleted,\n            biometric_enabled: profile.biometricEnabled,\n            weight: profile.weight,\n            height: profile.height,\n            birth_date: profile.birthDate,\n            diabetes_condition: profile.condition,\n            restriction: profile.restriction,\n            syncedAt: serverTimestamp(), \n        };\n\n        await setDoc(userRef, profileData, { merge: true });\n\n        // Atualiza a marca d'água de sincronização no SQLite\n        await new Promise<void>((resolve, reject) => {\n            getDB().transaction(\n                (tx: SQLite.SQLTransaction) => { \n                    tx.executeSql(\n                        `UPDATE users SET synced_at = ? WHERE id = ?;`,\n                        [new Date().toISOString(), profile.id],\n                        () => resolve(), \n                        (_, err) => { reject(err); return false; } \n                    );\n                },\n                (err) => reject(err), \n                () => resolve() \n            );\n        });\n\n        console.log(`Perfil do usuário ${uid} sincronizado no Firestore.`);\n    } catch (error) {\n        console.error(\"Erro ao sincronizar perfil do usuário com Firestore:\", error);\n        throw error;\n    }\n}\n\n\n/**\n * Sincroniza o objeto Reading com o Cloud Firestore.\n */\nexport async function syncReadingToFirestore(reading: Reading): Promise<void> {\n    const uid = getFirebaseUID();\n\n    if (!uid) {\n        console.warn(\"Usuário não autenticado no Firebase. Sincronização de leitura ignorada.\");\n        return;\n    }\n\n    try {\n        const readingRef = doc(db, 'users', uid, 'readings', reading.id);\n        \n        const readingData = {\n            id: reading.id,\n            glucose_level: reading.glucose_level,\n            meal_context: reading.meal_context,\n            time_since_meal: reading.time_since_meal,\n            notes: reading.notes,\n            timestamp: reading.timestamp, \n            measurement_time_iso: reading.measurement_time, \n            syncedAt: serverTimestamp(), \n            userId: uid,\n        };\n        \n        await setDoc(readingRef, readingData);\n\n        // Atualiza a marca d'água de sincronização no SQLite\n        await new Promise<void>((resolve, reject) => {\n            getDB().transaction(\n                (tx: SQLite.SQLTransaction) => {\n                    tx.executeSql(\n                        `UPDATE readings SET synced_at = ? WHERE id = ?;`,\n                        [new Date().toISOString(), reading.id],\n                        () => resolve(), \n                        (_, err) => { reject(err); return false; } \n                    );\n                },\n                (err) => reject(err), \n                () => resolve() \n            );\n        });\n\n        console.log(`Leitura ${reading.id} sincronizada no Firestore.`);\n    } catch (error) {\n        console.error(\"Erro ao sincronizar leitura com Firestore:\", error);\n        throw error;\n    }\n}\n\n// ----------------------\n// FUNÇÕES DE MANIPULAÇÃO DE DADOS\n// ----------------------\n\n/**\n * Salvar ou atualizar usuário (Chama Sincronização)\n */\nexport async function saveOrUpdateUser(profile: UserProfile): Promise<UserProfile | boolean> {\n    const database = getDB();\n\n    return new Promise((resolve, reject) => {\n        database.transaction(\n            (tx: SQLite.SQLTransaction) => {\n                tx.executeSql(\n                    `INSERT OR REPLACE INTO users \n                     (id, full_name, email, google_id, onboarding_completed, biometric_enabled,\n                     weight, height, birth_date, diabetes_condition, restriction, synced_at)\n                     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);`,\n                    [\n                        profile.id,\n                        profile.name || null,\n                        profile.email || null,\n                        profile.googleId || null,\n                        profile.onboardingCompleted ? 1 : 0,\n                        profile.biometricEnabled ? 1 : 0,\n                        profile.weight || null,\n                        profile.height || null,\n                        profile.birthDate || null, \n                        profile.condition || null, \n                        profile.restriction || null, \n                        profile.syncedAt || null, \n                    ]\n                );\n            },\n            (err) => {\n                console.error('saveOrUpdateUser - erro transaction:', err);\n                reject(err);\n            },\n            async () => {\n                try {\n                    const user = await getUser(); \n                    if (user) {\n                        // Chama a sincronização APÓS salvar localmente\n                        await syncUserProfileToFirestore(user); \n                        resolve(user);\n                    } else {\n                        resolve(false); \n                    }\n                } catch (err) {\n                    console.error('saveOrUpdateUser - erro ao buscar ou sincronizar:', err);\n                    // Se a sincronização falhar, ainda consideramos o salvamento local um sucesso\n                    const user = await getUser();\n                    resolve(user || false); \n                }\n            }\n        );\n    });\n}\n\n/**\n * Inserir leitura (Chama Sincronização)\n */\nexport async function addReading(reading: Reading): Promise<boolean> {\n    const database = getDB();\n\n    // Garante que a measurement_time seja uma string ISO\n    const isoTime = new Date(reading.timestamp).toISOString();\n    \n    // Sobrescreve o campo measurement_time na Reading antes de sincronizar/salvar\n    const readingToSave: Reading = {\n        ...reading,\n        measurement_time: isoTime,\n    };\n\n    return new Promise((resolve, reject) => {\n        database.transaction(\n            (tx: SQLite.SQLTransaction) => {\n                tx.executeSql(\n                    `INSERT INTO readings \n                          (id, measurement_time, glucose_level, meal_context, time_since_meal, notes)\n                          VALUES (?, ?, ?, ?, ?, ?)`,\n                    [\n                        readingToSave.id,\n                        readingToSave.measurement_time, \n                        readingToSave.glucose_level,\n                        readingToSave.meal_context || null,\n                        readingToSave.time_since_meal || null,\n                        readingToSave.notes || null,\n                    ]\n                );\n            },\n            (err) => {\n                console.error('addReading - erro transaction:', err);\n                reject(err);\n            },\n            async () => {\n                try {\n                    // Chama a sincronização APÓS salvar localmente\n                    await syncReadingToFirestore(readingToSave); \n                    resolve(true);\n                } catch (error) {\n                    // A falha na sincronização não impede o sucesso local\n                    console.warn('Atenção: Falha na sincronização da leitura. Salvo apenas localmente.');\n                    resolve(true);\n                }\n            }\n        );\n    });\n}\n\n/**\n * Buscar usuário único\n */\nexport async function getUser(): Promise<UserProfile | null> {\n    const database = getDB();\n\n    return new Promise((resolve, reject) => {\n        database.transaction((tx: SQLite.SQLTransaction) => {\n            tx.executeSql(\n                `SELECT * FROM users LIMIT 1;`,\n                [],\n                // Usando tipagem correta para o resultado\n                (_, { rows }: { rows: SQLite.SQLResultSetRowList }) => { \n                    if (rows.length > 0) {\n                        resolve(normalizeUserRow(rows._array[0])); \n                    } else {\n                        resolve(null); \n                    }\n                },\n                (_, err) => {\n                    console.error('getUser - erro:', err);\n                    reject(err);\n                    return false;\n                }\n            );\n        });\n    });\n}\n\n/**\n * Listar leituras\n */\nexport async function listReadings(): Promise<Reading[]> {\n    const database = getDB();\n\n    return new Promise((resolve, reject) => {\n        database.transaction(\n            (tx: SQLite.SQLTransaction) => {\n                tx.executeSql(\n                    `SELECT * FROM readings ORDER BY datetime(measurement_time) DESC;`,\n                    [],\n                    (_, result) => {\n                        const readings = (result.rows._array || []).map(normalizeReadingRow);\n                        resolve(readings);\n                    }\n                );\n            },\n            (err) => {\n                console.error('listReadings - erro transaction:', err);\n                reject(err);\n            }\n        );\n    });\n}\n\n/**\n * Excluir leitura por ID\n */\nexport async function deleteReading(id: string): Promise<boolean> {\n    const database = getDB();\n\n    return new Promise((resolve, reject) => {\n        database.transaction(\n            (tx: SQLite.SQLTransaction) => {\n                tx.executeSql(\n                    'DELETE FROM readings WHERE id = ?;',\n                    [id],\n                    (_, result) => {\n                        resolve(result.rowsAffected > 0); \n                    },\n                    (_, error) => {\n                        console.error(\"deleteReading - erro SQL:\", error);\n                        reject(error);\n                        return false;\n                    }\n                );\n            },\n            (error) => {\n                console.error(\"deleteReading - erro transaction:\", error);\n                reject(error);\n            },\n            () => {\n                resolve(true);\n            } \n        );\n    });\n}\n\n// ----------------------\n// FUNÇÕES DE LIMPEZA DE ESTADO (CORREÇÃO/NOVO)\n// ----------------------\n\n/**\n * Remove o único usuário (perfil) do banco de dados local (SQLite).\n * ESSENCIAL para ser chamada no logout.\n */\nexport async function clearUser(): Promise<boolean> {\n    const database = getDB();\n\n    return new Promise((resolve, reject) => {\n        database.transaction(\n            (tx: SQLite.SQLTransaction) => {\n                tx.executeSql(\n                    `DELETE FROM users;`,\n                    [],\n                    () => {\n                        // Opcional: Limpar todas as leituras se desejar que o estado local seja completamente zerado no logout.\n                        // tx.executeSql(`DELETE FROM readings;`); \n                        resolve(true); \n                    },\n                    (_, error) => {\n                        console.error(\"clearUser - erro SQL:\", error);\n                        reject(error);\n                        return false;\n                    }\n                );\n            },\n            (error) => {\n                console.error(\"clearUser - erro transaction:\", error);\n                reject(error);\n            },\n            () => {\n                resolve(true);\n            }\n        );\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}