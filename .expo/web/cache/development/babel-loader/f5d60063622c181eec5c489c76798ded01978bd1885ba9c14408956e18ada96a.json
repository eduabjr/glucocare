{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport * as SQLite from 'expo-sqlite';\nimport { db, auth } from \"../config/firebase\";\nimport { doc, setDoc, serverTimestamp } from 'firebase/firestore';\nvar DB_NAME = 'glucocare.db';\nvar dbInstance = null;\nexport function getDB() {\n  if (!dbInstance) {\n    dbInstance = SQLite.openDatabase(DB_NAME);\n  }\n  return dbInstance;\n}\nexport function initDB() {\n  return _initDB.apply(this, arguments);\n}\nfunction _initDB() {\n  _initDB = _asyncToGenerator(function* () {\n    return new Promise(function (resolve, reject) {\n      var database = getDB();\n      database.transaction(function (tx) {\n        tx.executeSql(\"CREATE TABLE IF NOT EXISTS users (\\n                        id TEXT PRIMARY KEY NOT NULL,\\n                        full_name TEXT,\\n                        email TEXT,\\n                        google_id TEXT,\\n                        onboarding_completed INTEGER DEFAULT 0,\\n                        biometric_enabled INTEGER DEFAULT 0,\\n                        weight REAL,\\n                        height REAL,\\n                        birth_date TEXT,\\n                        diabetes_condition TEXT,\\n                        restriction TEXT,\\n                        synced_at TEXT DEFAULT NULL \\n                    );\");\n        tx.executeSql(\"CREATE TABLE IF NOT EXISTS readings (\\n                        id TEXT PRIMARY KEY NOT NULL,\\n                        measurement_time TEXT,\\n                        glucose_level REAL,\\n                        meal_context TEXT,\\n                        time_since_meal TEXT,\\n                        notes TEXT,\\n                        synced_at TEXT DEFAULT NULL \\n                    );\");\n        tx.executeSql(\"CREATE TABLE IF NOT EXISTS sync_meta (\\n                        key TEXT PRIMARY KEY NOT NULL,\\n                        value TEXT\\n                    );\");\n      }, function (err) {\n        console.error('initDB - erro transaction:', err);\n        reject(err);\n      }, function () {\n        console.log('Banco inicializado com sucesso ‚úÖ');\n        resolve(true);\n      });\n    });\n  });\n  return _initDB.apply(this, arguments);\n}\nfunction normalizeUserRow(row) {\n  var _row$full_name, _row$email, _row$google_id, _row$weight, _row$height, _row$birth_date, _row$diabetes_conditi, _row$restriction, _row$synced_at;\n  return {\n    id: row.id,\n    name: String((_row$full_name = row.full_name) != null ? _row$full_name : ''),\n    email: String((_row$email = row.email) != null ? _row$email : ''),\n    googleId: String((_row$google_id = row.google_id) != null ? _row$google_id : ''),\n    onboardingCompleted: !!row.onboarding_completed,\n    biometricEnabled: !!row.biometric_enabled,\n    weight: (_row$weight = row.weight) != null ? _row$weight : null,\n    height: (_row$height = row.height) != null ? _row$height : null,\n    birthDate: String((_row$birth_date = row.birth_date) != null ? _row$birth_date : ''),\n    condition: String((_row$diabetes_conditi = row.diabetes_condition) != null ? _row$diabetes_conditi : ''),\n    restriction: String((_row$restriction = row.restriction) != null ? _row$restriction : ''),\n    syncedAt: (_row$synced_at = row.synced_at) != null ? _row$synced_at : null\n  };\n}\nfunction normalizeReadingRow(row) {\n  var _row$meal_context, _row$time_since_meal, _row$notes, _row$synced_at2;\n  var timestamp = row.measurement_time ? new Date(row.measurement_time).getTime() : Date.now();\n  return {\n    id: row.id,\n    measurement_time: String(row.measurement_time),\n    timestamp: timestamp,\n    glucose_level: row.glucose_level,\n    meal_context: (_row$meal_context = row.meal_context) != null ? _row$meal_context : null,\n    time_since_meal: (_row$time_since_meal = row.time_since_meal) != null ? _row$time_since_meal : null,\n    notes: (_row$notes = row.notes) != null ? _row$notes : null,\n    syncedAt: (_row$synced_at2 = row.synced_at) != null ? _row$synced_at2 : null\n  };\n}\nfunction getFirebaseUID() {\n  var _auth$currentUser;\n  return ((_auth$currentUser = auth.currentUser) == null ? void 0 : _auth$currentUser.uid) || null;\n}\nexport function syncUserProfileToFirestore(_x) {\n  return _syncUserProfileToFirestore.apply(this, arguments);\n}\nfunction _syncUserProfileToFirestore() {\n  _syncUserProfileToFirestore = _asyncToGenerator(function* (profile) {\n    var uid = getFirebaseUID();\n    if (!uid) {\n      console.warn(\"Usu√°rio n√£o autenticado no Firebase. Sincroniza√ß√£o de perfil ignorada.\");\n      return;\n    }\n    try {\n      var userRef = doc(db, 'users', uid);\n      var profileData = {\n        full_name: profile.name,\n        email: profile.email,\n        google_id: profile.googleId,\n        onboarding_completed: profile.onboardingCompleted,\n        biometric_enabled: profile.biometricEnabled,\n        weight: profile.weight,\n        height: profile.height,\n        birth_date: profile.birthDate,\n        diabetes_condition: profile.condition,\n        restriction: profile.restriction,\n        syncedAt: serverTimestamp()\n      };\n      yield setDoc(userRef, profileData, {\n        merge: true\n      });\n      yield new Promise(function (resolve, reject) {\n        getDB().transaction(function (tx) {\n          tx.executeSql(\"UPDATE users SET synced_at = ? WHERE id = ?;\", [new Date().toISOString(), profile.id], function () {\n            return resolve();\n          }, function (_, err) {\n            reject(err);\n            return false;\n          });\n        }, function (err) {\n          return reject(err);\n        }, function () {\n          return resolve();\n        });\n      });\n      console.log(\"Perfil do usu\\xE1rio \" + uid + \" sincronizado no Firestore.\");\n    } catch (error) {\n      console.error(\"Erro ao sincronizar perfil do usu√°rio com Firestore:\", error);\n      throw error;\n    }\n  });\n  return _syncUserProfileToFirestore.apply(this, arguments);\n}\nexport function syncReadingToFirestore(_x2) {\n  return _syncReadingToFirestore.apply(this, arguments);\n}\nfunction _syncReadingToFirestore() {\n  _syncReadingToFirestore = _asyncToGenerator(function* (reading) {\n    var uid = getFirebaseUID();\n    if (!uid) {\n      console.warn(\"Usu√°rio n√£o autenticado no Firebase. Sincroniza√ß√£o de leitura ignorada.\");\n      return;\n    }\n    try {\n      var readingRef = doc(db, 'users', uid, 'readings', reading.id);\n      var readingData = {\n        id: reading.id,\n        glucose_level: reading.glucose_level,\n        meal_context: reading.meal_context,\n        time_since_meal: reading.time_since_meal,\n        notes: reading.notes,\n        timestamp: reading.timestamp,\n        measurement_time_iso: reading.measurement_time,\n        syncedAt: serverTimestamp(),\n        userId: uid\n      };\n      yield setDoc(readingRef, readingData);\n      yield new Promise(function (resolve, reject) {\n        getDB().transaction(function (tx) {\n          tx.executeSql(\"UPDATE readings SET synced_at = ? WHERE id = ?;\", [new Date().toISOString(), reading.id], function () {\n            return resolve();\n          }, function (_, err) {\n            reject(err);\n            return false;\n          });\n        }, function (err) {\n          return reject(err);\n        }, function () {\n          return resolve();\n        });\n      });\n      console.log(\"Leitura \" + reading.id + \" sincronizada no Firestore.\");\n    } catch (error) {\n      console.error(\"Erro ao sincronizar leitura com Firestore:\", error);\n      throw error;\n    }\n  });\n  return _syncReadingToFirestore.apply(this, arguments);\n}\nexport function saveOrUpdateUser(_x3) {\n  return _saveOrUpdateUser.apply(this, arguments);\n}\nfunction _saveOrUpdateUser() {\n  _saveOrUpdateUser = _asyncToGenerator(function* (profile) {\n    var database = getDB();\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql(\"INSERT OR REPLACE INTO users \\n                     (id, full_name, email, google_id, onboarding_completed, biometric_enabled,\\n                      weight, height, birth_date, diabetes_condition, restriction, synced_at)\\n                      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\", [profile.id, profile.name || null, profile.email || null, profile.googleId || null, profile.onboardingCompleted ? 1 : 0, profile.biometricEnabled ? 1 : 0, profile.weight || null, profile.height || null, profile.birthDate || null, profile.condition || null, profile.restriction || null, profile.syncedAt || null]);\n      }, function (err) {\n        console.error('saveOrUpdateUser - erro transaction:', err);\n        reject(err);\n      }, _asyncToGenerator(function* () {\n        try {\n          var user = yield getUser();\n          if (user) {\n            yield syncUserProfileToFirestore(user);\n            resolve(user);\n          } else {\n            resolve(false);\n          }\n        } catch (err) {\n          console.error('saveOrUpdateUser - erro ao buscar ou sincronizar:', err);\n          var _user = yield getUser();\n          resolve(_user || false);\n        }\n      }));\n    });\n  });\n  return _saveOrUpdateUser.apply(this, arguments);\n}\nexport function addReading(_x4) {\n  return _addReading.apply(this, arguments);\n}\nfunction _addReading() {\n  _addReading = _asyncToGenerator(function* (reading) {\n    var database = getDB();\n    var isoTime = new Date(reading.timestamp).toISOString();\n    var readingToSave = _objectSpread(_objectSpread({}, reading), {}, {\n      measurement_time: isoTime\n    });\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql(\"INSERT INTO readings \\n                         (id, measurement_time, glucose_level, meal_context, time_since_meal, notes)\\n                         VALUES (?, ?, ?, ?, ?, ?)\", [readingToSave.id, readingToSave.measurement_time, readingToSave.glucose_level, readingToSave.meal_context || null, readingToSave.time_since_meal || null, readingToSave.notes || null]);\n      }, function (err) {\n        console.error('addReading - erro transaction:', err);\n        reject(err);\n      }, _asyncToGenerator(function* () {\n        try {\n          yield syncReadingToFirestore(readingToSave);\n          resolve(true);\n        } catch (error) {\n          console.warn('Aten√ß√£o: Falha na sincroniza√ß√£o da leitura. Salvo apenas localmente.');\n          resolve(true);\n        }\n      }));\n    });\n  });\n  return _addReading.apply(this, arguments);\n}\nexport function getUser() {\n  return _getUser.apply(this, arguments);\n}\nfunction _getUser() {\n  _getUser = _asyncToGenerator(function* () {\n    var database = getDB();\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql(\"SELECT * FROM users LIMIT 1;\", [], function (_, _ref3) {\n          var rows = _ref3.rows;\n          if (rows.length > 0) {\n            resolve(normalizeUserRow(rows._array[0]));\n          } else {\n            resolve(null);\n          }\n        }, function (_, err) {\n          console.error('getUser - erro:', err);\n          reject(err);\n          return false;\n        });\n      });\n    });\n  });\n  return _getUser.apply(this, arguments);\n}\nexport function listReadings() {\n  return _listReadings.apply(this, arguments);\n}\nfunction _listReadings() {\n  _listReadings = _asyncToGenerator(function* () {\n    var database = getDB();\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql(\"SELECT * FROM readings ORDER BY datetime(measurement_time) DESC;\", [], function (_, result) {\n          var readings = (result.rows._array || []).map(normalizeReadingRow);\n          resolve(readings);\n        });\n      }, function (err) {\n        console.error('listReadings - erro transaction:', err);\n        reject(err);\n      });\n    });\n  });\n  return _listReadings.apply(this, arguments);\n}\nexport function deleteReading(_x5) {\n  return _deleteReading.apply(this, arguments);\n}\nfunction _deleteReading() {\n  _deleteReading = _asyncToGenerator(function* (id) {\n    var database = getDB();\n    return new Promise(function (resolve, reject) {\n      database.transaction(function (tx) {\n        tx.executeSql('DELETE FROM readings WHERE id = ?;', [id], function (_, result) {\n          resolve(result.rowsAffected > 0);\n        }, function (_, error) {\n          console.error(\"deleteReading - erro SQL:\", error);\n          reject(error);\n          return false;\n        });\n      }, function (error) {\n        console.error(\"deleteReading - erro transaction:\", error);\n        reject(error);\n      }, function () {\n        resolve(true);\n      });\n    });\n  });\n  return _deleteReading.apply(this, arguments);\n}","map":{"version":3,"names":["SQLite","db","auth","doc","setDoc","serverTimestamp","DB_NAME","dbInstance","getDB","openDatabase","initDB","_initDB","apply","arguments","_asyncToGenerator","Promise","resolve","reject","database","transaction","tx","executeSql","err","console","error","log","normalizeUserRow","row","_row$full_name","_row$email","_row$google_id","_row$weight","_row$height","_row$birth_date","_row$diabetes_conditi","_row$restriction","_row$synced_at","id","name","String","full_name","email","googleId","google_id","onboardingCompleted","onboarding_completed","biometricEnabled","biometric_enabled","weight","height","birthDate","birth_date","condition","diabetes_condition","restriction","syncedAt","synced_at","normalizeReadingRow","_row$meal_context","_row$time_since_meal","_row$notes","_row$synced_at2","timestamp","measurement_time","Date","getTime","now","glucose_level","meal_context","time_since_meal","notes","getFirebaseUID","_auth$currentUser","currentUser","uid","syncUserProfileToFirestore","_x","_syncUserProfileToFirestore","profile","warn","userRef","profileData","merge","toISOString","_","syncReadingToFirestore","_x2","_syncReadingToFirestore","reading","readingRef","readingData","measurement_time_iso","userId","saveOrUpdateUser","_x3","_saveOrUpdateUser","user","getUser","addReading","_x4","_addReading","isoTime","readingToSave","_objectSpread","_getUser","_ref3","rows","length","_array","listReadings","_listReadings","result","readings","map","deleteReading","_x5","_deleteReading","rowsAffected"],"sources":["C:/Users/Usu√°rio/Desktop/glucocare/src/services/dbService.ts"],"sourcesContent":["import * as SQLite from 'expo-sqlite';\n// ‚úÖ CORRE√á√ÉO 1: Importa√ß√£o ajustada para o caminho mais prov√°vel\nimport { db, auth } from '../config/firebase'; \nimport { doc, setDoc, serverTimestamp, getDoc } from 'firebase/firestore'; \nimport { User as FirebaseAuthUser } from 'firebase/auth'; \n// ‚úÖ CORRE√á√ÉO 2: Importe a tipagem para transa√ß√£o do SQLite\nimport { SQLTransaction, SQLResultSetRowList } from 'expo-sqlite'; \n\n// Definindo o nome do banco\nconst DB_NAME = 'glucocare.db';\nlet dbInstance: SQLite.Database | null = null; \n\n// ----------------------\n// TIPAGEM\n// ----------------------\n\nexport interface UserProfile {\n    id: string;\n    name: string;\n    email: string;\n    googleId: string;\n    onboardingCompleted: boolean;\n    biometricEnabled: boolean;\n    weight: number | null;\n    height: number | null;\n    birthDate: string;\n    condition: string;\n    restriction: string;\n    syncedAt: string | null;\n}\n\n/**\n * Interface de Leitura adaptada para o uso da propriedade 'timestamp'\n * para importa√ß√£o de arquivos (usada no fileParsingService).\n */\nexport interface Reading {\n    id: string;\n    // Campo usado para salvar no SQLite (ISO string)\n    measurement_time: string; \n    // Novo campo: Usado pelo parser de arquivos (milissegundos UNIX)\n    timestamp: number; \n    glucose_level: number;\n    meal_context: string | null;\n    time_since_meal: string | null;\n    notes: string | null;\n    syncedAt: string | null; \n}\n\n// ----------------------\n// FUN√á√ïES DE SERVI√áO B√ÅSICAS\n// ----------------------\n\n/**\n * Retorna inst√¢ncia √∫nica do DB\n */\nexport function getDB(): SQLite.Database {\n    if (!dbInstance) {\n        dbInstance = SQLite.openDatabase(DB_NAME);\n    }\n    return dbInstance;\n}\n\n/**\n * Inicializa tabelas do banco\n */\nexport async function initDB(): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n        const database = getDB();\n\n        database.transaction(\n            (tx: SQLTransaction) => { // Tx tipado\n                // Usu√°rios\n                tx.executeSql(\n                    `CREATE TABLE IF NOT EXISTS users (\n                        id TEXT PRIMARY KEY NOT NULL,\n                        full_name TEXT,\n                        email TEXT,\n                        google_id TEXT,\n                        onboarding_completed INTEGER DEFAULT 0,\n                        biometric_enabled INTEGER DEFAULT 0,\n                        weight REAL,\n                        height REAL,\n                        birth_date TEXT,\n                        diabetes_condition TEXT,\n                        restriction TEXT,\n                        synced_at TEXT DEFAULT NULL \n                    );`\n                );\n\n                // Leituras\n                tx.executeSql(\n                    `CREATE TABLE IF NOT EXISTS readings (\n                        id TEXT PRIMARY KEY NOT NULL,\n                        measurement_time TEXT,\n                        glucose_level REAL,\n                        meal_context TEXT,\n                        time_since_meal TEXT,\n                        notes TEXT,\n                        synced_at TEXT DEFAULT NULL \n                    );`\n                );\n\n                // Metadados de sincroniza√ß√£o\n                tx.executeSql(\n                    `CREATE TABLE IF NOT EXISTS sync_meta (\n                        key TEXT PRIMARY KEY NOT NULL,\n                        value TEXT\n                    );`\n                );\n            },\n            (err) => {\n                console.error('initDB - erro transaction:', err);\n                reject(err);\n            },\n            () => {\n                console.log('Banco inicializado com sucesso ‚úÖ');\n                resolve(true);\n            }\n        );\n    });\n}\n\n// ----------------------\n// FUN√á√ïES DE NORMALIZA√á√ÉO\n// ----------------------\n\nfunction normalizeUserRow(row: any): UserProfile {\n    return {\n        id: row.id,\n        name: String(row.full_name ?? ''), \n        email: String(row.email ?? ''), \n        googleId: String(row.google_id ?? ''), \n        onboardingCompleted: !!row.onboarding_completed,\n        biometricEnabled: !!row.biometric_enabled,\n        weight: row.weight ?? null, \n        height: row.height ?? null, \n        birthDate: String(row.birth_date ?? ''), \n        condition: String(row.diabetes_condition ?? ''), \n        restriction: String(row.restriction ?? ''),\n        syncedAt: row.synced_at ?? null, \n    };\n}\n\nfunction normalizeReadingRow(row: any): Reading {\n    // üí° Ao normalizar do SQLite, preenchemos o timestamp para ser consistente\n    const timestamp = row.measurement_time ? new Date(row.measurement_time).getTime() : Date.now();\n    \n    return {\n        id: row.id,\n        measurement_time: String(row.measurement_time),\n        timestamp: timestamp, // Preenchemos o campo timestamp a partir da string\n        glucose_level: row.glucose_level,\n        meal_context: row.meal_context ?? null,\n        time_since_meal: row.time_since_meal ?? null,\n        notes: row.notes ?? null,\n        syncedAt: row.synced_at ?? null, \n    };\n}\n\n// ----------------------\n// FUN√á√ïES DE SINCRONIZA√á√ÉO (FIREBASE)\n// ----------------------\n\n/**\n * Retorna o UID do usu√°rio logado no Firebase Auth.\n */\nfunction getFirebaseUID(): string | null {\n    return auth.currentUser?.uid || null;\n}\n\n/**\n * Sincroniza o objeto UserProfile com o Cloud Firestore.\n */\nexport async function syncUserProfileToFirestore(profile: UserProfile): Promise<void> {\n    const uid = getFirebaseUID();\n\n    if (!uid) {\n        console.warn(\"Usu√°rio n√£o autenticado no Firebase. Sincroniza√ß√£o de perfil ignorada.\");\n        return;\n    }\n\n    try {\n        const userRef = doc(db, 'users', uid);\n\n        const profileData = {\n            full_name: profile.name,\n            email: profile.email,\n            google_id: profile.googleId,\n            onboarding_completed: profile.onboardingCompleted,\n            biometric_enabled: profile.biometricEnabled,\n            weight: profile.weight,\n            height: profile.height,\n            birth_date: profile.birthDate,\n            diabetes_condition: profile.condition,\n            restriction: profile.restriction,\n            syncedAt: serverTimestamp(), \n        };\n\n        await setDoc(userRef, profileData, { merge: true });\n\n        // Atualiza a marca d'√°gua de sincroniza√ß√£o no SQLite\n        await new Promise<void>((resolve, reject) => {\n            getDB().transaction(\n                (tx: SQLTransaction) => { \n                    tx.executeSql(\n                        `UPDATE users SET synced_at = ? WHERE id = ?;`,\n                        [new Date().toISOString(), profile.id],\n                        () => resolve(), \n                        (_, err) => { reject(err); return false; } \n                    );\n                },\n                (err) => reject(err), \n                () => resolve() \n            );\n        });\n\n        console.log(`Perfil do usu√°rio ${uid} sincronizado no Firestore.`);\n    } catch (error) {\n        console.error(\"Erro ao sincronizar perfil do usu√°rio com Firestore:\", error);\n        throw error;\n    }\n}\n\n\n/**\n * Sincroniza o objeto Reading com o Cloud Firestore.\n */\nexport async function syncReadingToFirestore(reading: Reading): Promise<void> {\n    const uid = getFirebaseUID();\n\n    if (!uid) {\n        console.warn(\"Usu√°rio n√£o autenticado no Firebase. Sincroniza√ß√£o de leitura ignorada.\");\n        return;\n    }\n\n    try {\n        const readingRef = doc(db, 'users', uid, 'readings', reading.id);\n        \n        // üí° CONVERS√ÉO: O Firestore deve usar a hora Unix (number) ou o ISO String.\n        // J√° que a interface Reading usa 'timestamp' (number) e 'measurement_time' (string),\n        // vamos usar o 'timestamp' para o Firestore, que √© mais f√°cil de ordenar.\n        const readingData = {\n            id: reading.id,\n            glucose_level: reading.glucose_level,\n            meal_context: reading.meal_context,\n            time_since_meal: reading.time_since_meal,\n            notes: reading.notes,\n            timestamp: reading.timestamp, // Usa o timestamp (number)\n            measurement_time_iso: reading.measurement_time, // Guarda a string como refer√™ncia\n            syncedAt: serverTimestamp(), \n            userId: uid,\n        };\n        \n        await setDoc(readingRef, readingData);\n\n        // Atualiza a marca d'√°gua de sincroniza√ß√£o no SQLite\n        await new Promise<void>((resolve, reject) => {\n            getDB().transaction(\n                (tx: SQLTransaction) => {\n                    tx.executeSql(\n                        `UPDATE readings SET synced_at = ? WHERE id = ?;`,\n                        [new Date().toISOString(), reading.id],\n                        () => resolve(), \n                        (_, err) => { reject(err); return false; } \n                    );\n                },\n                (err) => reject(err), \n                () => resolve() \n            );\n        });\n\n        console.log(`Leitura ${reading.id} sincronizada no Firestore.`);\n    } catch (error) {\n        console.error(\"Erro ao sincronizar leitura com Firestore:\", error);\n        throw error;\n    }\n}\n\n// ----------------------\n// FUN√á√ïES DE MANIPULA√á√ÉO DE DADOS\n// ----------------------\n\n/**\n * Salvar ou atualizar usu√°rio (Chama Sincroniza√ß√£o)\n */\nexport async function saveOrUpdateUser(profile: UserProfile): Promise<UserProfile | boolean> {\n    const database = getDB();\n\n    return new Promise((resolve, reject) => {\n        database.transaction(\n            (tx: SQLTransaction) => {\n                // CORRE√á√ÉO: Adiciona 'synced_at' √† lista de colunas e par√¢metros do INSERT OR REPLACE\n                tx.executeSql(\n                    `INSERT OR REPLACE INTO users \n                     (id, full_name, email, google_id, onboarding_completed, biometric_enabled,\n                      weight, height, birth_date, diabetes_condition, restriction, synced_at)\n                      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);`, // Adicionado um '?'\n                    [\n                        profile.id,\n                        profile.name || null,\n                        profile.email || null,\n                        profile.googleId || null,\n                        profile.onboardingCompleted ? 1 : 0,\n                        profile.biometricEnabled ? 1 : 0,\n                        profile.weight || null,\n                        profile.height || null,\n                        profile.birthDate || null, \n                        profile.condition || null, \n                        profile.restriction || null, \n                        profile.syncedAt || null, // Novo par√¢metro\n                    ]\n                );\n            },\n            (err) => {\n                console.error('saveOrUpdateUser - erro transaction:', err);\n                reject(err);\n            },\n            async () => {\n                try {\n                    const user = await getUser(); \n                    if (user) {\n                        // Chama a sincroniza√ß√£o AP√ìS salvar localmente\n                        await syncUserProfileToFirestore(user); \n                        resolve(user);\n                    } else {\n                        resolve(false); \n                    }\n                } catch (err) {\n                    console.error('saveOrUpdateUser - erro ao buscar ou sincronizar:', err);\n                    // Se a sincroniza√ß√£o falhar, ainda consideramos o salvamento local um sucesso\n                    const user = await getUser();\n                    resolve(user || false); \n                }\n            }\n        );\n    });\n}\n\n/**\n * Inserir leitura (Chama Sincroniza√ß√£o)\n */\nexport async function addReading(reading: Reading): Promise<boolean> {\n    const database = getDB();\n\n    // üí° CONVERS√ÉO PRINCIPAL: Garante que a measurement_time seja uma string ISO\n    // usando o 'timestamp' (milissegundos) que vem do fileParsingService.\n    const isoTime = new Date(reading.timestamp).toISOString();\n    \n    // Sobrescreve o campo measurement_time na Reading antes de sincronizar/salvar\n    const readingToSave: Reading = {\n        ...reading,\n        measurement_time: isoTime,\n    };\n\n    return new Promise((resolve, reject) => {\n        database.transaction(\n            (tx: SQLTransaction) => {\n                tx.executeSql(\n                    `INSERT INTO readings \n                         (id, measurement_time, glucose_level, meal_context, time_since_meal, notes)\n                         VALUES (?, ?, ?, ?, ?, ?)`,\n                    [\n                        readingToSave.id,\n                        readingToSave.measurement_time, // String ISO\n                        readingToSave.glucose_level,\n                        readingToSave.meal_context || null,\n                        readingToSave.time_since_meal || null,\n                        readingToSave.notes || null,\n                    ]\n                );\n            },\n            (err) => {\n                console.error('addReading - erro transaction:', err);\n                reject(err);\n            },\n            async () => {\n                try {\n                    // Chama a sincroniza√ß√£o AP√ìS salvar localmente\n                    await syncReadingToFirestore(readingToSave); \n                    resolve(true);\n                } catch (error) {\n                    // A falha na sincroniza√ß√£o n√£o impede o sucesso local\n                    console.warn('Aten√ß√£o: Falha na sincroniza√ß√£o da leitura. Salvo apenas localmente.');\n                    resolve(true);\n                }\n            }\n        );\n    });\n}\n\n/**\n * Buscar usu√°rio √∫nico\n */\nexport async function getUser(): Promise<UserProfile | null> {\n    const database = getDB();\n\n    return new Promise((resolve, reject) => {\n        database.transaction((tx: SQLTransaction) => {\n            tx.executeSql(\n                `SELECT * FROM users LIMIT 1;`,\n                [],\n                (_, { rows }: { rows: SQLResultSetRowList }) => {\n                    if (rows.length > 0) {\n                        resolve(normalizeUserRow(rows._array[0])); \n                    } else {\n                        resolve(null); \n                    }\n                },\n                (_, err) => {\n                    console.error('getUser - erro:', err);\n                    reject(err);\n                    return false;\n                }\n            );\n        });\n    });\n}\n\n/**\n * Listar leituras\n */\nexport async function listReadings(): Promise<Reading[]> {\n    const database = getDB();\n\n    return new Promise((resolve, reject) => {\n        database.transaction(\n            (tx: SQLTransaction) => {\n                tx.executeSql(\n                    `SELECT * FROM readings ORDER BY datetime(measurement_time) DESC;`,\n                    [],\n                    (_, result) => {\n                        // Mapeia os resultados para o tipo Reading\n                        const readings = (result.rows._array || []).map(normalizeReadingRow);\n                        resolve(readings);\n                    }\n                );\n            },\n            (err) => {\n                console.error('listReadings - erro transaction:', err);\n                reject(err);\n            }\n        );\n    });\n}\n\n/**\n * Excluir leitura por ID\n */\nexport async function deleteReading(id: string): Promise<boolean> {\n    const database = getDB();\n\n    return new Promise((resolve, reject) => {\n        database.transaction(\n            (tx: SQLTransaction) => {\n                tx.executeSql(\n                    'DELETE FROM readings WHERE id = ?;',\n                    [id],\n                    (_, result) => {\n                        // Verifica se alguma linha foi afetada\n                        resolve(result.rowsAffected > 0); \n                    },\n                    (_, error) => {\n                        console.error(\"deleteReading - erro SQL:\", error);\n                        reject(error);\n                        return false;\n                    }\n                );\n            },\n            (error) => {\n                console.error(\"deleteReading - erro transaction:\", error);\n                reject(error);\n            },\n            () => {\n                resolve(true);\n            } \n        );\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}