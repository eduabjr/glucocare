Tecnologias que você já está usando no projeto:

React Native (Expo)
TypeScript
Firebase (Auth + Firestore, Google OAuth)
React Navigation
Context API
Expo LocalAuthentication (biometria)
Expo SecureStore (segredos/credenciais)
AsyncStorage (preferências simples)
Ícones @expo/vector-icons

Banco de dados local/offline (recomendação):

Para dados críticos e estruturados (leituras de glicemia, anotações): use SQLite via expo-sqlite ou uma camada sobre SQLite como WatermelonDB. 
São persistentes, performáticas e permitem sync posterior com Firestore.


Para preferências/cache leve: AsyncStorage (key-value).
Para segredos/tokens: Expo SecureStore.
Observação: usando Firebase Web SDK no Expo puro, o Firestore NÃO tem persistência offline durável por padrão em React Native. Portanto, se você precisa de funcionamento 100% offline, mantenha os dados localmente (SQLite/WatermelonDB) e faça uma fila de sincronização com o Firestore quando a rede voltar.
Sugestão prática:
Leituras: tabela local (SQLite) com campos id, timestamp, valor, origem, synced_at.
Fila de sync: marca pendingSync e envia ao Firestore quando online.
Preferências do usuário: AsyncStorage.
Segredos: SecureStore.



2) Banco de dados no Expo hoje e no futuro
Online: Firebase Auth + Firestore (já usa).
Offline/local: use SQLite. No Expo, use expo-sqlite (ou expo-sqlite/next para APIs modernas). Alternativas de alto nível: WatermelonDB (usa SQLite por baixo), RxDB (exige setup mais avançado).
3) Por que Firestore offline “não resolve sozinho” no RN/Expo
O Firestore Web SDK em React Native não oferece a mesma persistência offline durável que no Android/iOS nativos. Você pode ter cache temporário, mas não uma base confiável para operar 100% offline com grandes volumes. Por isso, apps que precisam funcionar bem offline mantêm os dados críticos em SQLite e fazem sincronização com o Firestore quando a rede volta.
4) Como usar SQLite para local e sincronizar com Firestore
Modelo de dados local (exemplo conceitual):
Tabela readings com colunas: id, userId, value, unit, takenAt, source, updatedAt, deleted (0/1), pendingSync (0/1).
Tabela sync_state para checkpoints (ex.: lastPulledAt por usuário).
Operação offline-first:
Create/Update/Delete local → seta pendingSync=1 e atualiza updatedAt.
UI lê SEMPRE do SQLite.
Sincronização periódica (foreground, background fetch ou gatilho manual):
Push:
Seleciona registros pendingSync=1.
Envia ao Firestore (cria/atualiza documentos, marca deleted como exclusão lógica).
Ao sucesso, limpa pendingSync e grava syncedAt.
Pull:
Busca no Firestore itens com updatedAt > lastPulledAt.
Faz upsert no SQLite; se veio deleted=1, marca como deletado local.
Atualiza lastPulledAt.
Resolução de conflitos:
Estratégia simples: last-write-wins usando updatedAt.
Estratégia mais segura: comparar updatedAt e, havendo conflito, manter a versão mais recente e logar diferenças; opcionalmente notificar usuário.
Segurança e consistência:
Valide userId em regras do Firestore.
Use lotes/transactions quando enviar múltiplos registros.
Estados offline:
Fila de sync acessória para anexos/arquivos (se houver).
Indicadores de status (ex.: “pendente de sincronização”).
5) Impacto no seu código atual (conceitos, sem você editar agora)
Serviços:
Criar um localDbService (SQLite) para CRUD das leituras e um syncService para push/pull com Firestore.
O glucoseService/contexts passam a ler do SQLite, não direto do Firestore.
Telas:
Continuam consumindo o ReadingsContext/hooks; internamente esse contexto consulta SQLite e dispara sync quando online.
Auth:
Ao logar, defina o userId para filtrar tabelas locais e iniciar uma sync inicial (pull).
Background:
Pode usar “BackgroundFetch” (Expo) para rodar sync periódico; ou sincronizar no app foreground (onFocus / intervalos).
6) Quando sair do Expo?
Fique no Expo enquanto:
expo-sqlite, SecureStore, LocalAuthentication e o resto atendem suas necessidades.
Publicação via EAS funciona para você.
Considere prebuild/bare apenas se:
Precisar de módulos nativos sem suporte em Expo.
Precisar customizar profundamente build nativo.
7) Resumo prático
Você pode lançar com Expo sem “remover tudo”.
Use expo-sqlite para local e implemente um fluxo de sync com Firestore (push/pull, flags pendingSync, timestamps).
Mantenha UI lendo do SQLite para ser de fato offline-first.
Controle conflitos com updatedAt e trate exclusões como lógicas para facilitar merge.
Se quiser, eu descrevo um esquema de tabelas e endpoints Firestore mais detalhado, e uma sequência de operações do syncService passo a passo.

SHA-1 CD:94:7C:DC:66:7C:A2:17:E3:AD:27:0B:23:4B:D9:E2:1D:F6:26:D1